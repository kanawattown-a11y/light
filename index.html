<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ù†Ø¸Ø§Ù… Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ø³ÙŠÙ†Ù…Ø§Ø¦ÙŠ - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ø£Ù‚ÙˆÙ‰ v10.0 Ultimate</title>
    <style>
        :root {
            --bg-color: #0a0a0a; 
            --panel-bg: rgba(10, 12, 15, 0.95); 
            --text-color: #ffffff;
            --primary-color: #00ff88; 
            --secondary-color: #ff6b35;
            --accent-color: #8b5cf6;
            --border-color: rgba(255, 255, 255, 0.15); 
            --header-bg: #1a1a2e;
            --input-bg: #16213e; 
            --hover-bg: #0f3460;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --glow-color: #00ff88;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: var(--text-color);
            overflow: hidden;
            position: relative;
        }

        /* Animated background particles */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: var(--glow-color);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 0 6px var(--glow-color);
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.7; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        #viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(0, 255, 136, 0.1) 0%, transparent 70%);
        }

        .panel {
            position: absolute;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.7), 0 0 20px rgba(0, 255, 136, 0.1);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .panel:hover {
            box-shadow: 0 16px 50px rgba(0, 0, 0, 0.8), 0 0 30px rgba(0, 255, 136, 0.2);
            transform: translateY(-2px);
        }

        .panel-header {
            background: linear-gradient(135deg, var(--header-bg) 0%, var(--primary-color) 100%);
            padding: 15px;
            font-weight: bold;
            border-radius: 12px 12px 0 0;
            cursor: move;
            user-select: none;
            color: #000;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .panel-content {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) transparent;
        }

        .panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .panel-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 3px;
        }

        #left-panel {
            top: 20px;
            left: 20px;
            width: 320px;
            height: calc(100vh - 40px);
        }

        #right-panel {
            top: 20px;
            right: 20px;
            width: 360px;
            height: calc(100vh - 40px);
        }

        #bottom-panel {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 200px;
        }

        h4 {
            margin: 0 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--primary-color);
            color: var(--primary-color);
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text-color);
            font-weight: 500;
        }

        input, select, button {
            width: 100%;
            padding: 12px;
            background: var(--input-bg);
            border: 2px solid transparent;
            color: var(--text-color);
            border-radius: 6px;
            box-sizing: border-box;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        button {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
            color: #000;
            border: none;
            cursor: pointer;
            margin-top: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            background: linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%);
            color: white;
        }

        button.warning {
            background: linear-gradient(135deg, var(--warning-color) 0%, #d97706 100%);
            color: white;
        }

        #scene-outliner ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #scene-outliner li {
            display: flex;
            align-items: center;
            padding: 12px;
            cursor: pointer;
            border-radius: 6px;
            margin-bottom: 5px;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        #scene-outliner li:hover {
            background: var(--hover-bg);
            border-color: var(--primary-color);
            transform: translateX(5px);
        }

        #scene-outliner li.selected {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
            color: #000;
            font-weight: bold;
        }

        #scene-outliner li .icon {
            margin-left: 12px;
            font-size: 18px;
        }

        #scene-outliner li .visibility {
            margin-right: auto;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        #scene-outliner li .visibility:hover {
            opacity: 1;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px 6px 0 0;
            position: relative;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tab.active {
            background: var(--primary-color);
            color: #000;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .asset-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .asset-item:hover {
            background: var(--hover-bg);
            border-color: var(--primary-color);
            transform: scale(1.02);
        }

        .asset-item img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            margin-left: 15px;
            border: 2px solid var(--primary-color);
        }

        #notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--success-color) 0%, #059669 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            display: none;
            z-index: 10000;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(10px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 255, 136, 0.3);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .performance-monitor {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--primary-color);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
        }

        .fps-counter {
            color: var(--primary-color);
            font-weight: bold;
        }

        .gpu-info {
            color: var(--secondary-color);
            margin-right: 15px;
        }

        .ai-status {
            color: var(--accent-color);
            margin-right: 15px;
        }

        /* WebGPU Canvas Styles */
        #webgpu-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Advanced UI Components */
        .slider-container {
            position: relative;
            margin: 10px 0;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--input-bg);
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        /* AI Panel Styles */
        .ai-panel {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .ai-status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success-color);
            margin-left: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Physics Panel Styles */
        .physics-panel {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.1) 0%, rgba(255, 107, 53, 0.05) 100%);
            border: 1px solid var(--secondary-color);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        /* WebAssembly Status */
        .wasm-status {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(16, 185, 129, 0.05) 100%);
            border: 1px solid var(--success-color);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            #left-panel, #right-panel {
                width: 280px;
            }
            #bottom-panel {
                width: 500px;
            }
        }

        @media (max-width: 768px) {
            #left-panel {
                width: 250px;
                left: 10px;
            }
            #right-panel {
                width: 250px;
                right: 10px;
            }
            #bottom-panel {
                width: 90%;
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <!-- Background Particles -->
    <div class="bg-particles" id="bg-particles"></div>

    <!-- Performance Monitor -->
    <div class="performance-monitor">
        <span class="fps-counter">FPS: <span id="fps-display">0</span></span>
        <span class="gpu-info">GPU: <span id="gpu-display">ØªØ­Ù…ÙŠÙ„...</span></span>
        <span class="ai-status">AI: <span id="ai-display">ØºÙŠØ± Ù†Ø´Ø·</span></span>
        <span class="wasm-status">WASM: <span id="wasm-display">ØºÙŠØ± Ù…Ø­Ù…Ù„</span></span>
    </div>

    <!-- Main Viewport -->
    <div id="viewport">
       
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div>
            <div class="loading-spinner"></div>
            <p style="margin-top: 20px; text-align: center;">ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…...</p>
        </div>
    </div>

    <!-- Left Panel: Scene Management & Assets -->
    <div id="left-panel" class="panel">
        <div class="panel-header">ğŸ¬ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ø£ØµÙˆÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
        <div class="panel-content">
            <div class="tabs">
                <div class="tab active" data-tab="outliner-tab">Ø§Ù„Ø·Ø¨Ù‚Ø§Øª</div>
                <div class="tab" data-tab="assets-tab">Ù…ÙƒØªØ¨Ø© Ø§Ù„Ø£ØµÙˆÙ„</div>
                <div class="tab" data-tab="ai-tab">Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</div>
            </div>
            
            <div id="outliner-tab" class="tab-content active">
                <button id="import-model-btn">â• Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù†Ù…ÙˆØ°Ø¬ GLB/GLTF</button>
                <input type="file" id="import-model-input" accept=".glb,.gltf" style="display:none;" multiple>
                <button id="export-glb-btn" class="warning">ğŸ“¤ ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ GLB</button>
                <button id="export-scene-btn" class="warning">ğŸ’¾ ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„ÙƒØ§Ù…Ù„</button>
                <hr style="margin: 15px 0; border: 1px solid var(--border-color);">
                <div id="scene-outliner"><ul></ul></div>
            </div>
            
            <div id="assets-tab" class="tab-content">
                <h4>Ø£ØµÙˆÙ„ Ø¬Ø§Ù‡Ø²Ø© Ù…ØªÙ‚Ø¯Ù…Ø©</h4>
                <button id="generate-procedural-btn">ğŸ² ØªÙˆÙ„ÙŠØ¯ Ø£ØµÙˆÙ„ Ø¥Ø¬Ø±Ø§Ø¦ÙŠØ©</button>
                <button id="ai-enhance-btn">ğŸ¤– ØªØ­Ø³ÙŠÙ† Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</button>
                <div id="asset-library"></div>
            </div>
            
            <div id="ai-tab" class="tab-content">
                <div class="ai-panel">
                    <h4>Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</h4>
                    <div>Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…: <span class="ai-status-indicator"></span> Ù†Ø´Ø·</div>
                    <button id="ai-object-recognition">ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª</button>
                    <button id="ai-performance-optimize">âš¡ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ</button>
                    <button id="ai-content-generate">ğŸ¨ ØªÙˆÙ„ÙŠØ¯ Ù…Ø­ØªÙˆÙ‰ Ø°ÙƒÙŠ</button>
                    <div class="control-group">
                        <label>Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ:</label>
                        <input type="range" class="slider" id="ai-level" min="1" max="10" value="5">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Panel: Properties & Environment -->
    <div id="right-panel" class="panel">
        <div class="panel-header">âš™ï¸ Ø§Ù„Ø®ØµØ§Ø¦Øµ ÙˆØ§Ù„Ø¨ÙŠØ¦Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</div>
        <div class="panel-content" id="properties-panel">
            <!-- Dynamic content will be populated here -->
        </div>
    </div>

    <!-- Bottom Panel: Physics & Advanced Controls -->
    <div id="bottom-panel" class="panel">
        <div class="panel-header">ğŸ”¬ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡ ÙˆØ§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</div>
        <div class="panel-content">
            <div class="tabs">
                <div class="tab active" data-tab="physics-tab">Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡</div>
                <div class="tab" data-tab="rendering-tab">Ø§Ù„Ø¹Ø±Ø¶</div>
                <div class="tab" data-tab="wasm-tab">WebAssembly</div>
            </div>
            
            <div id="physics-tab" class="tab-content active">
                <div class="physics-panel">
                    <div class="control-group-grid">
                        <div>
                            <label>Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ©:</label>
                            <input type="range" class="slider" id="gravity" min="-50" max="50" value="-9.8" step="0.1">
                        </div>
                        <div>
                            <label>Ø§Ù„Ø§Ø­ØªÙƒØ§Ùƒ:</label>
                            <input type="range" class="slider" id="friction" min="0" max="2" value="0.5" step="0.01">
                        </div>
                        <div>
                            <label>Ø§Ù„Ø§Ø±ØªØ¯Ø§Ø¯:</label>
                            <input type="range" class="slider" id="restitution" min="0" max="1" value="0.3" step="0.01">
                        </div>
                    </div>
                    <button id="physics-toggle">ğŸ”„ ØªÙØ¹ÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡</button>
                    <button id="physics-reset">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡</button>
                </div>
            </div>
            
            <div id="rendering-tab" class="tab-content">
                <div class="control-group-grid">
                    <div>
                        <label>Ø¬ÙˆØ¯Ø© Ø§Ù„Ø¸Ù„Ø§Ù„:</label>
                        <select id="shadow-quality">
                            <option value="low">Ù…Ù†Ø®ÙØ¶Ø©</option>
                            <option value="medium" selected>Ù…ØªÙˆØ³Ø·Ø©</option>
                            <option value="high">Ø¹Ø§Ù„ÙŠØ©</option>
                            <option value="ultra">ÙØ§Ø¦Ù‚Ø©</option>
                        </select>
                    </div>
                    <div>
                        <label>Ù…ÙƒØ§ÙØ­Ø© Ø§Ù„ØªØ´ÙˆÙŠØ´:</label>
                        <select id="antialiasing">
                            <option value="none">Ø¨Ø¯ÙˆÙ†</option>
                            <option value="fxaa">FXAA</option>
                            <option value="msaa" selected>MSAA</option>
                            <option value="taa">TAA</option>
                        </select>
                    </div>
                    <div>
                        <label>Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ©:</label>
                        <input type="checkbox" id="global-illumination">
                    </div>
                </div>
            </div>
            
            <div id="wasm-tab" class="tab-content">
                <div class="wasm-status">
                    <div>Ø­Ø§Ù„Ø© WebAssembly: <span id="wasm-status-text">ØºÙŠØ± Ù…Ø­Ù…Ù„</span></div>
                    <div>Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©: <span id="wasm-memory">0 MB</span></div>
                    <div>Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©: <span id="wasm-operations">0</span></div>
                </div>
                <button id="wasm-benchmark">ğŸš€ Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¯Ø§Ø¡ WASM</button>
                <button id="wasm-physics-enable">âš¡ ØªÙØ¹ÙŠÙ„ ÙÙŠØ²ÙŠØ§Ø¡ WASM</button>
            </div>
        </div>
    </div>

    <!-- Notification System -->
    <div id="notification"></div>

    <!-- Import Maps for Modern Module Loading -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.167.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.167.0/examples/jsm/",
                "@tensorflow/tfjs": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js",
                "@tensorflow/tfjs-backend-webgl": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.15.0/dist/tf-backend-webgl.min.js",
                "@tensorflow/tfjs-backend-cpu": "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-cpu@4.15.0/dist/tf-backend-cpu.min.js"
            }
        }
    </script>




<script type="module">
    // ===== ULTIMATE 3D SYSTEM - MAIN APPLICATION =====
    
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TransformControls } from "three/addons/controls/TransformControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
    import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

    // Global State Management
    class UltimateSystemState {
        constructor( ) {
            this.webgpuSupported = false;
            this.webgpuDevice = null;
            this.webgpuContext = null;
            this.aiModelsLoaded = false;
            this.wasmModuleLoaded = false;
            this.physicsEnabled = false;
            this.selectedObject = null;
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.performanceStats = {
                fps: 0,
                frameTime: 0,
                drawCalls: 0,
                triangles: 0
            };
        }
    }

    const systemState = new UltimateSystemState();

    // ===== WEBGPU INITIALIZATION =====
    async function initWebGPU() {
        try {
            if (!navigator.gpu) {
                console.warn('WebGPU not supported, falling back to WebGL');
                return false;
            }

            const adapter = await navigator.gpu.requestAdapter({
                powerPreference: 'high-performance'
            });
            
            if (!adapter) {
                console.warn('No WebGPU adapter found');
                return false;
            }

            const device = await adapter.requestDevice({
                requiredFeatures: [],
                requiredLimits: {}
            });

            const canvas = document.getElementById('webgpu-canvas');
            const context = canvas.getContext('webgpu');
            
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device: device,
                format: canvasFormat,
                alphaMode: 'premultiplied'
            });

            systemState.webgpuSupported = true;
            systemState.webgpuDevice = device;
            systemState.webgpuContext = context;

            updateGPUDisplay(adapter.info || { vendor: 'WebGPU', architecture: 'Unknown' });
            showNotification('WebGPU ØªÙ… ØªÙ‡ÙŠØ¦ØªÙ‡ Ø¨Ù†Ø¬Ø§Ø­!', false);
            
            return true;
        } catch (error) {
            console.error('WebGPU initialization failed:', error);
            showNotification('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© WebGPUØŒ Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… WebGL', true);
            return false;
        }
    }

    // ===== TENSORFLOW.JS AI INITIALIZATION =====
    async function initAI() {
        try {
            // Load TensorFlow.js
            // The importmap handles the direct import of tfjs and its backends
            // No need for explicit import() calls here if using importmap
            
            // Set backend preference
            if (systemState.webgpuSupported) {
                await tf.setBackend('webgl');
            } else {
                await tf.setBackend('cpu');
            }

            // In a real implementation, you would load actual models
            systemState.aiModelsLoaded = true;
            updateAIDisplay('Ù†Ø´Ø· - Ù†Ù…Ø§Ø°Ø¬ Ù…Ø­Ù…Ù„Ø©');
            showNotification('Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¬Ø§Ù‡Ø²!', false);
            
            return true;
        } catch (error) {
            console.error('AI initialization failed:', error);
            updateAIDisplay('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„');
            return false;
        }
    }

    // ===== WEBASSEMBLY INITIALIZATION =====
    async function initWebAssembly() {
        try {
            // In a real implementation, you would load actual WASM modules
            // For demonstration, we'll simulate WASM loading
            
            // Simulate loading time
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            systemState.wasmModuleLoaded = true;
            updateWASMDisplay('Ù…Ø­Ù…Ù„');
            document.getElementById('wasm-status-text').textContent = 'Ù…Ø­Ù…Ù„ ÙˆÙ†Ø´Ø·';
            showNotification('WebAssembly ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡ Ø¨Ù†Ø¬Ø§Ø­!', false);
            
            return true;
        } catch (error) {
            console.error('WASM initialization failed:', error);
            updateWASMDisplay('ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„');
            return false;
        }
    }

    // ===== THREE.JS SCENE SETUP (CORRECTED) =====
    async function initThreeJS() {
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75, 
            window.innerWidth / window.innerHeight, 
            0.1, 
            2000
        );
        camera.position.set(15, 10, 25);
        camera.name = "MainCamera";
        
        // *** START: CORRECTED RENDERER SETUP ***
        // Renderer setup (fallback to WebGL if WebGPU not available)
        // We let Three.js create its own canvas to avoid context conflicts.
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            powerPreference: "high-performance",
            alpha: true
        });
        
        // Add the renderer's canvas to our viewport div
        const viewport = document.getElementById('viewport');
        viewport.appendChild(renderer.domElement);
        // *** END: CORRECTED RENDERER SETUP ***

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        // Controls - they will correctly use the renderer's canvas
        const orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        
        const transformControls = new TransformControls(camera, renderer.domElement);
        scene.add(transformControls);

        // Advanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(50, 50, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        scene.add(directionalLight);

        // Environment map for realistic reflections
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        new RGBELoader()
            .setPath('assets/textures/') // Assuming HDRIs are in an assets/textures folder
            .load('royal_esplanade_1k.hdr', (texture) => {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                scene.environment = envMap;
                texture.dispose();
                pmremGenerator.dispose();
            });

        // Add a ground plane
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // Post-processing for bloom effect
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 0.5; // Adjust bloom strength
        bloomPass.radius = 0;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Draco Loader for GLTF compression
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');

        // GLTF Loader
        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);

        // Store in systemState
        systemState.scene = scene;
        systemState.camera = camera;
        systemState.renderer = renderer;
        systemState.orbitControls = orbitControls;
        systemState.transformControls = transformControls;
        systemState.gltfLoader = gltfLoader;
        systemState.composer = composer;

        // Example: Add a default cube
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ff88, metalness: 0.5, roughness: 0.5 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0.5, 0);
        cube.castShadow = true;
        cube.receiveShadow = true;
        cube.name = "DefaultCube";
        cube.userData.isSelectable = true;
        scene.add(cube);

        // Add to outliner
        addSceneObjectToOutliner(cube);

        // Initial selection
        systemState.selectedObject = cube;
        transformControls.attach(cube);
        updatePropertiesPanel(cube);

        // Setup click for object selection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                // Traverse up to find a selectable parent if the clicked object is part of a group
                while (clickedObject && !clickedObject.userData.isSelectable && clickedObject !== scene) {
                    clickedObject = clickedObject.parent;
                }

                if (clickedObject && clickedObject.userData.isSelectable) {
                    if (systemState.selectedObject) {
                        // Deselect previous
                        const prevSelectedElement = document.querySelector(`#scene-outliner li[data-uuid="${systemState.selectedObject.uuid}"]`);
                        if (prevSelectedElement) prevSelectedElement.classList.remove('selected');
                    }
                    systemState.selectedObject = clickedObject;
                    transformControls.attach(clickedObject);
                    updatePropertiesPanel(clickedObject);

                    // Select in outliner
                    const selectedElement = document.querySelector(`#scene-outliner li[data-uuid="${clickedObject.uuid}"]`);
                    if (selectedElement) selectedElement.classList.add('selected');
                }
            } else {
                // Clicked on empty space, deselect
                if (systemState.selectedObject) {
                    const prevSelectedElement = document.querySelector(`#scene-outliner li[data-uuid="${systemState.selectedObject.uuid}"]`);
                    if (prevSelectedElement) prevSelectedElement.classList.remove('selected');
                    systemState.selectedObject = null;
                    transformControls.detach();
                    updatePropertiesPanel(null);
                }
            }
        });

        // Handle TransformControls change event to update properties panel
        transformControls.addEventListener('objectChange', () => {
            if (systemState.selectedObject) {
                updatePropertiesPanel(systemState.selectedObject);
            }
        });

        // Add default particle system
        addAdvancedParticleSystem();
    }

    // ===== SCENE OUTLINER FUNCTIONS =====
    function addSceneObjectToOutliner(object) {
        const outliner = document.getElementById('scene-outliner').querySelector('ul');
        const listItem = document.createElement('li');
        listItem.dataset.uuid = object.uuid;
        listItem.innerHTML = `
            <span class="icon">${getIconForObjectType(object.type)}</span>
            <span>${object.name || object.type}</span>
            <span class="visibility" data-uuid="${object.uuid}" data-visible="${object.visible}">ğŸ‘ï¸</span>
        `;
        outliner.appendChild(listItem);

        listItem.addEventListener('click', (event) => {
            // Prevent selecting object when clicking visibility icon
            if (event.target.classList.contains('visibility')) return;

            if (systemState.selectedObject) {
                const prevSelectedElement = document.querySelector(`#scene-outliner li[data-uuid="${systemState.selectedObject.uuid}"]`);
                if (prevSelectedElement) prevSelectedElement.classList.remove('selected');
            }
            systemState.selectedObject = object;
            systemState.transformControls.attach(object);
            updatePropertiesPanel(object);
            listItem.classList.add('selected');
        });

        // Toggle visibility
        listItem.querySelector('.visibility').addEventListener('click', (event) => {
            object.visible = !object.visible;
            event.target.textContent = object.visible ? 'ğŸ‘ï¸' : 'ğŸš«';
            event.target.dataset.visible = object.visible;
        });
    }

    function getIconForObjectType(type) {
        switch (type) {
            case 'Scene': return 'ğŸŒ';
            case 'PerspectiveCamera': return 'ğŸ“¸';
            case 'DirectionalLight': return 'ğŸ’¡';
            case 'AmbientLight': return 'ğŸ’¡';
            case 'Mesh': return 'ğŸ“¦';
            case 'Points': return 'âœ¨';
            default: return 'â“';
        }
    }

    // ===== PROPERTIES PANEL FUNCTIONS =====
    function updatePropertiesPanel(object) {
        const panel = document.getElementById('properties-panel');
        panel.innerHTML = ''; // Clear previous content

        if (!object) {
            panel.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.5);">Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒØ§Ø¦Ù† Ù…Ø­Ø¯Ø¯</p>';
            return;
        }

        panel.innerHTML += `<h4>${object.name || object.type} - Ø§Ù„Ø®ØµØ§Ø¦Øµ</h4>`;

        // Position
        panel.innerHTML += `
            <div class="control-group">
                <label>Ø§Ù„Ù…ÙˆØ¶Ø¹ (X, Y, Z):</label>
                <div class="control-group-grid">
                    <input type="number" id="prop-posX" value="${object.position.x.toFixed(2)}" step="0.1">
                    <input type="number" id="prop-posY" value="${object.position.y.toFixed(2)}" step="0.1">
                    <input type="number" id="prop-posZ" value="${object.position.z.toFixed(2)}" step="0.1">
                </div>
            </div>
        `;
        document.getElementById('prop-posX').addEventListener('input', (e) => { object.position.x = parseFloat(e.target.value); });
        document.getElementById('prop-posY').addEventListener('input', (e) => { object.position.y = parseFloat(e.target.value); });
        document.getElementById('prop-posZ').addEventListener('input', (e) => { object.position.z = parseFloat(e.target.value); });

        // Rotation (Euler angles for simplicity)
        panel.innerHTML += `
            <div class="control-group">
                <label>Ø§Ù„Ø¯ÙˆØ±Ø§Ù† (X, Y, Z - Ø¯Ø±Ø¬Ø§Øª):</label>
                <div class="control-group-grid">
                    <input type="number" id="prop-rotX" value="${THREE.MathUtils.radToDeg(object.rotation.x).toFixed(2)}" step="1">
                    <input type="number" id="prop-rotY" value="${THREE.MathUtils.radToDeg(object.rotation.y).toFixed(2)}" step="1">
                    <input type="number" id="prop-rotZ" value="${THREE.MathUtils.radToDeg(object.rotation.z).toFixed(2)}" step="1">
                </div>
            </div>
        `;
        document.getElementById('prop-rotX').addEventListener('input', (e) => { object.rotation.x = THREE.MathUtils.degToRad(parseFloat(e.target.value)); });
        document.getElementById('prop-rotY').addEventListener('input', (e) => { object.rotation.y = THREE.MathUtils.degToRad(parseFloat(e.target.value)); });
        document.getElementById('prop-rotZ').addEventListener('input', (e) => { object.rotation.z = THREE.MathUtils.degToRad(parseFloat(e.target.value)); });

        // Scale
        panel.innerHTML += `
            <div class="control-group">
                <label>Ø§Ù„Ø­Ø¬Ù… (X, Y, Z):</label>
                <div class="control-group-grid">
                    <input type="number" id="prop-scaleX" value="${object.scale.x.toFixed(2)}" step="0.1">
                    <input type="number" id="prop-scaleY" value="${object.scale.y.toFixed(2)}" step="0.1">
                    <input type="number" id="prop-scaleZ" value="${object.scale.z.toFixed(2)}" step="0.1">
                </div>
            </div>
        `;
        document.getElementById('prop-scaleX').addEventListener('input', (e) => { object.scale.x = parseFloat(e.target.value); });
        document.getElementById('prop-scaleY').addEventListener('input', (e) => { object.scale.y = parseFloat(e.target.value); });
        document.getElementById('prop-scaleZ').addEventListener('input', (e) => { object.scale.z = parseFloat(e.target.value); });

        // Material properties if it's a Mesh
        if (object.isMesh && object.material) {
            panel.innerHTML += `<h4>Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø§Ø¯Ø©</h4>`;
            if (object.material.color) {
                panel.innerHTML += `
                    <div class="control-group">
                        <label>Ø§Ù„Ù„ÙˆÙ†:</label>
                        <input type="color" id="prop-color" value="#${object.material.color.getHexString()}">
                    </div>
                `;
                document.getElementById('prop-color').addEventListener('input', (e) => { object.material.color.set(e.target.value); });
            }
            if (object.material.metalness !== undefined) {
                panel.innerHTML += `
                    <div class="control-group">
                        <label>Ø§Ù„Ù…Ø¹Ø¯Ù†ÙŠØ©:</label>
                        <input type="range" class="slider" id="prop-metalness" min="0" max="1" value="${object.material.metalness.toFixed(2)}" step="0.01">
                    </div>
                `;
                document.getElementById('prop-metalness').addEventListener('input', (e) => { object.material.metalness = parseFloat(e.target.value); });
            }
            if (object.material.roughness !== undefined) {
                panel.innerHTML += `
                    <div class="control-group">
                        <label>Ø§Ù„Ø®Ø´ÙˆÙ†Ø©:</label>
                        <input type="range" class="slider" id="prop-roughness" min="0" max="1" value="${object.material.roughness.toFixed(2)}" step="0.01">
                    </div>
                `;
                document.getElementById('prop-roughness').addEventListener('input', (e) => { object.material.roughness = parseFloat(e.target.value); });
            }
        }

        // Add more properties as needed
    }

    // ===== ASSET MANAGEMENT FUNCTIONS =====
    document.getElementById('import-model-btn')?.addEventListener('click', () => {
        document.getElementById('import-model-input').click();
    });

    document.getElementById('import-model-input')?.addEventListener('change', (event) => {
        const files = event.target.files;
        if (files.length === 0) return;

        showNotification(`Ø¬Ø§Ø±ÙŠ Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${files.length} Ù†Ù…ÙˆØ°Ø¬...`, false);
        
        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                systemState.gltfLoader.parse(e.target.result, '', (gltf) => {
                    const model = gltf.scene;
                    model.name = file.name.split('.')[0]; // Use filename as object name
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            child.userData.isSelectable = true; // Make all meshes selectable
                        }
                    });
                    systemState.scene.add(model);
                    addSceneObjectToOutliner(model);
                    showNotification(`ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ${file.name} Ø¨Ù†Ø¬Ø§Ø­!`, false);
                }, (error) => {
                    console.error('Error loading GLTF:', error);
                    showNotification(`ÙØ´Ù„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ${file.name}`, true);
                });
            };
            reader.readAsArrayBuffer(file);
        }
    });

    document.getElementById('export-glb-btn')?.addEventListener('click', () => {
        if (!systemState.selectedObject) {
            showNotification('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ø¯ÙŠØ¯ ÙƒØ§Ø¦Ù† Ù„ØªØµØ¯ÙŠØ±Ù‡.', true);
            return;
        }

        showNotification(`Ø¬Ø§Ø±ÙŠ ØªØµØ¯ÙŠØ± ${systemState.selectedObject.name || systemState.selectedObject.type} Ø¥Ù„Ù‰ GLB...`, false);

        const exporter = new THREE.GLTFExporter();
        exporter.parse(
            systemState.selectedObject,
            (result) => {
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${systemState.selectedObject.name || 'scene_object'}.glb`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification('ØªÙ… ØªØµØ¯ÙŠØ± GLB Ø¨Ù†Ø¬Ø§Ø­!', false);
            },
            (error) => {
                console.error('Error exporting GLB:', error);
                showNotification('ÙØ´Ù„ ØªØµØ¯ÙŠØ± GLB.', true);
            },
            {
                binary: true // Export as GLB
            }
        );
    });

    document.getElementById('export-scene-btn')?.addEventListener('click', () => {
        showNotification('Ø¬Ø§Ø±ÙŠ ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ø¥Ù„Ù‰ GLB...', false);

        const exporter = new THREE.GLTFExporter();
        exporter.parse(
            systemState.scene,
            (result) => {
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'full_scene.glb';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showNotification('ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ù†Ø¬Ø§Ø­!', false);
            },
            (error) => {
                console.error('Error exporting full scene GLB:', error);
                showNotification('ÙØ´Ù„ ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„ÙƒØ§Ù…Ù„.', true);
            },
            {
                binary: true // Export as GLB
            }
        );
    });

    // ===== ADVANCED PARTICLE SYSTEM =====
    function addAdvancedParticleSystem() {
        const particleCount = 5000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        const color = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            // Position
            const x = (Math.random() * 2 - 1) * 50;
            const y = (Math.random() * 2 - 1) * 50;
            const z = (Math.random() * 2 - 1) * 50;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            // Color (random shades of primary color)
            color.setHSL(0.3 + Math.random() * 0.2, 0.8, 0.5 + Math.random() * 0.3);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }

        const particles = new THREE.BufferGeometry();
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        // particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1)); // Removed as size is fixed in material

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.2, // Adjusted size for better visual
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        const particleSystem = new THREE.Points(particles, particleMaterial);
        particleSystem.name = "AdvancedParticleSystem";
        particleSystem.userData.isSelectable = true;
        systemState.scene.add(particleSystem);
    }

    // ===== PERFORMANCE MONITORING =====
    class PerformanceMonitor {
        constructor() {
            this.frameCount = 0;
            this.lastTime = performance.now();
            this.fps = 0;
        }

        update() {
            this.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - this.lastTime >= 1000) {
                this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
                this.frameCount = 0;
                this.lastTime = currentTime;
                
                document.getElementById('fps-display').textContent = this.fps;
                systemState.performanceStats.fps = this.fps;
            }
        }
    }

    const performanceMonitor = new PerformanceMonitor();

    // ===== ANIMATION LOOP =====
    function animate() {
        requestAnimationFrame(animate);
        
        performanceMonitor.update();
        
        if (systemState.orbitControls) {
            systemState.orbitControls.update();
        }
        
        // Animate particles
        if (systemState.scene) {
            const particleSystem = systemState.scene.getObjectByName("AdvancedParticleSystem");
            if (particleSystem) {
                particleSystem.rotation.y += 0.001;
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
        }
        
        if (systemState.composer) {
            systemState.composer.render();
        } else if (systemState.renderer && systemState.scene && systemState.camera) {
            systemState.renderer.render(systemState.scene, systemState.camera);
        }
    }

    // ===== UI HELPER FUNCTIONS =====
    function updateGPUDisplay(info) {
        document.getElementById('gpu-display').textContent = 
            `${info.vendor || 'Unknown'} ${info.architecture || ''}`;
    }

    function updateAIDisplay(status) {
        document.getElementById('ai-display').textContent = status;
    }

    function updateWASMDisplay(status) {
        document.getElementById('wasm-display').textContent = status;
    }

    function showNotification(message, isError = false) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.style.background = isError ? 
            'linear-gradient(135deg, var(--error-color) 0%, #dc2626 100%)' :
            'linear-gradient(135deg, var(--success-color) 0%, #059669 100%)';
        notification.style.display = 'block';
        
        setTimeout(() => {
            notification.style.display = 'none';
        }, 3000);
    }

    // ===== BACKGROUND PARTICLES =====
    function createBackgroundParticles() {
        const container = document.getElementById('bg-particles');
        const particleCount = 50;
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 6 + 's';
            particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
            container.appendChild(particle);
        }
    }

    // ===== EVENT LISTENERS =====
    function setupEventListeners() {
        // Window resize
        window.addEventListener('resize', () => {
            if (systemState.camera && systemState.renderer) {
                systemState.camera.aspect = window.innerWidth / window.innerHeight;
                systemState.camera.updateProjectionMatrix();
                systemState.renderer.setSize(window.innerWidth, window.innerHeight);
                if (systemState.composer) {
                    systemState.composer.setSize(window.innerWidth, window.innerHeight);
                }
            }
        });

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const parent = tab.closest('.panel-content');
                parent.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                parent.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                parent.querySelector(`#${tab.dataset.tab}`).classList.add('active');
            });
        });

        // AI Controls
        document.getElementById('ai-object-recognition')?.addEventListener('click', () => {
            showNotification('ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...', false);
            // Simulate AI processing
            setTimeout(() => {
                showNotification('ØªÙ… ØªØ­Ù„ÙŠÙ„ 5 ÙƒØ§Ø¦Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ø´Ù‡Ø¯', false);
            }, 2000);
        });

        document.getElementById('ai-performance-optimize')?.addEventListener('click', () => {
            showNotification('ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù†Ø´Ø·', false);
        });

        // Physics Controls
        document.getElementById('physics-toggle')?.addEventListener('click', () => {
            systemState.physicsEnabled = !systemState.physicsEnabled;
            showNotification(
                systemState.physicsEnabled ? 'ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡' : 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡', 
                false
            );
        });

        // WASM Controls
        document.getElementById('wasm-benchmark')?.addEventListener('click', () => {
            showNotification('ØªØ´ØºÙŠÙ„ Ø§Ø®ØªØ¨Ø§Ø± Ø£Ø¯Ø§Ø¡ WebAssembly...', false);
            // Simulate benchmark
            setTimeout(() => {
                showNotification('Ø§Ù„Ù†ØªÙŠØ¬Ø©: 15,000 Ø¹Ù…Ù„ÙŠØ©/Ø«Ø§Ù†ÙŠØ©', false);
            }, 3000);
        });
    }

    // ===== MAIN INITIALIZATION =====
    async function initializeUltimateSystem() {
        try {
            // Show loading
            document.getElementById('loading-overlay').style.display = 'flex';
            
            // Create background particles
            createBackgroundParticles();
            
            // Initialize core systems
            console.log('Initializing WebGPU...');
            await initWebGPU();
            
            console.log('Initializing AI systems...');
            await initAI();
            
            console.log('Initializing WebAssembly...');
            await initWebAssembly();
            
            console.log('Initializing 3D scene...');
            await initThreeJS();
            
            // Setup event listeners
            setupEventListeners();
            
            // Hide loading
            document.getElementById('loading-overlay').style.display = 'none';
            
            // Start animation loop
            animate();
            
            showNotification('Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ù‚ÙˆÙ‰ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…!', false);
            
        } catch (error) {
            console.error('System initialization failed:', error);
            showNotification('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù…', true);
            document.getElementById('loading-overlay').style.display = 'none';
        }
    }

    // Start the ultimate system
    initializeUltimateSystem();

</script>



</body>
</html>


